# [P1161 开灯](https://www.luogu.com.cn/problem/P1161)

## 题目描述

条无限长的路上，有排无限长的路灯，编号为1231
每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变
如果原来是开，将变成关。如果原来是关，将变成开
在刚开始的时侯，所有的灯都是关的。小明每次可以进行如下的操作
指定两个数，a,t(a为实数，为正整数)。将编号为a,2×a,3×a,txa的灯的开关各按一
次。其中시表示实数k的整数部分
在小明进行了m次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是
这盞灯离小明太远了，小明看不清编号是多少。
幸好，小明还记得之前的れ次操作。于是小明找到了你，你能帮他计算出这盞开着的灯的编号吗？

## 输入格式

第一行一个正整数n,表示n次操作。
接下来有n行，每行两个数，a,t。其中a是实数，小数点后一定有6位，t是正整数。

## 输出格式

仅一个正整数，那盏开着的灯的编号。

## 输入输出样例

**输入 #1**复制

```
3
1.618034 13
2.618034 7
1.000000 21
```

**输出 #1**复制

```
20
```

## 说明/提示

记t=t1+t2+t3+.+tn
对于30%的数据，满足T<1000
对于80%的数据，满足T<20000
对于100%的数据，满足T<2000000
对于100%的数据，满足れ≤5000,1≤a1<1000,1≤t≤T
数据保证，在经过n次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的1来说，tixai的最大值不超过2000000。

## 题解

### python

```python
import math
n=eval(input())
ls = [0 for i in range(2000000)]
for i in range(n):
    a, t = map(eval, input().split())
    for T in range(1,t+1):
        ls[math.floor(a*T)-1]=1 if ls[math.floor(a*T)-1]==0 else 0
print(ls.index(1)+1)
```

### c++

```cpp
#include <iostream>
using namespace std;
int ls[2000001]={0},n;
int main() {
    cin >>n;
    while (n--){
        int t;double a;
        cin >>a>>t;
        for (int i = 1; i <= t; ++i) {
            ls[int(a*i)-1]==0?ls[int(a*i)-1]=1:ls[int(a*i)-1]=0;
        }
    }
    for (int i = 0; i < 2000001; ++i) {
        if(ls[i]==1)cout<<i+1;
    }
    return 0;
}
```

